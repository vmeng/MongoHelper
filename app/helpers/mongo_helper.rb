# Copyright:: Copyright (c) PricewaterhouseCoopers LLP 2012

# This class provided base DB operation for all jobs
# Parameters ::nil

require 'mongo'
include Mongo

DEFAULT_DATABASE = 'mongo_helper_development'
MONGODB_URL = ENV['BOXEN_MONGODB_URL'] || ENV['MONGODB_URL'] || 'mongodb://localhost:27017'
MONGODB_URL = MONGODB_URL + '/' + DEFAULT_DATABASE unless ENV['MONGODB_URL']

#NOTE: MongoHelper assumes all _id fields are generated by Mongo (e.g. BSON objects)
module MongoHelper
  extend self
  @client = nil
  @db = nil
  @grid = nil

  # reset the logger lever
  logger = Mongo::Logger.logger
  logger.level = Logger::INFO
  Mongo::Logger.logger = logger
  #opens default database
  def open_database()
    begin
      # @db ||= MongoClient.from_uri(MONGODB_URL).db(URIParser.new(MONGODB_URL).db_name)
      @client ||= Mongo::Client.new(MONGODB_URL)
      # if @db

      # end
      Mongo::Database.create(@client)
      @db ||= @client.database
    rescue Errno::ECONNRESET => e
      puts "We are rescuing the error: " + e.message
      puts e.backtrace
    end
  end

    #opens default database
    def open_grid(db)
      begin
        @grid = Grid.new(db)
      rescue Errno::ECONNRESET => e
        puts "We are rescuing the error: " + e.message
        puts e.backtrace
      end
    end

  # Retrieve documents for a given query hash as an array
  # returns an empty array if no rows are found
  def get_documents_by_hash(query_hash, collection)
    begin
      records = []
      db = open_database()
      coll = db.collection(collection)
      records = coll.find(query_hash).to_a
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      recordsmog
    end
  end

   # Retrieve documents for a given query hash as an array with limitation
  # returns an empty array if no rows are found
  def get_documents_by_hash_with_limit(query_hash, collection, max_num)
    begin
      records = []
      db = open_database()
      coll = db.collection(collection)
      records = coll.find(query_hash).limit(max_num).to_a
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      records
    end
  end

  # Retrieve a single document based on a doc id
  # returns nil if no document is found
  def get_document_by_id(document_id, collection)
    begin
      query_hash = {'_id' => BSON::ObjectId.from_string(document_id)}
      db = open_database()
      coll = db.collection(collection)
      doc = coll.find(query_hash).to_a.first
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      nil
    end
  end

  # Retrieve a single document based on a key
  # returns nil if no document is found
  def get_document_by_key(key, collection)
    begin
      query_hash = {'_id' => key}
      db = open_database()
      coll = db.collection(collection)
      doc = coll.find_one(query_hash)
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      nil
    end
  end


  #returns nil if unsuccessful, returns the doc_id if successful
  #this will overwrite the existing document
  def save_document(doc_hash, collection='test')
    begin
      db = open_database()
      coll = db.collection(collection)
      #TODO: test code below before uncommenting
      # unless doc_hash['_id'].nil? && doc_hash['_id'].class == String
      #   doc_hash['_id'] = BSON::ObjectId(doc_hash['_id'])
      # end
      if !doc_hash['_id'].nil? && doc_hash['_id'].class == String # update doc
        doc_id = BSON::ObjectId.from_string(doc_hash['_id'])
        doc_hash_cloned = doc_hash.clone
        doc_hash_cloned.delete('_id')
        query_hash = {'_id' => doc_id}
        coll.find(query_hash).update_one('$set' => doc_hash_cloned)
        doc_id
      elsif doc_hash['_id'].class == BSON::ObjectId
        doc_id = doc_hash['_id']
        doc_hash_cloned = doc_hash.clone
        doc_hash_cloned.delete('_id')
        query_hash = {'_id' => doc_id}
        coll.find(query_hash).update_one('$set' => doc_hash_cloned)
        doc_id
      else
        result =  coll.insert_one(doc_hash)
        doc_id = result.inserted_ids.first.to_s
        doc_id
      end
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      doc_id
    end
  end


  def add_to_document(doc_id, doc_hash, collection)
    begin
      db = open_database()
      coll = db.collection(collection)
      coll.update({"_id" => BSON::ObjectId.from_string(doc_id)}, {"$set" => doc_hash})
      doc_id
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      doc_id
    end
  end

  # returns true if documents successfully insert
  def save_documents(doc_array, collection)
    begin
      db = open_database()
      coll = db.collection(collection)
      coll.insert_many(doc_array)
      true
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      false
    end
  end

  # returns true if document successfully deleted or does not exist
  def delete_documents_by_hash(query_hash, collection)
    begin
      db = open_database()
      coll = db.collection(collection)
      coll.remove(query_hash)
      true
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      false
    end
  end

  #returns true if the document exists in the collection
  def document_exists? (search_by, value, collection)
    begin
      #puts "Search by: #{search_by} Value: #{value} Collection: #{collection}"
      db = open_database()
      results = get_documents_by_hash({search_by => value}, collection)
      results.length > 0

    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      false
    end
  end

  #returns handle to collection or nil if collection does not exist
  def open_collection(collection)
    begin
      db = open_database()
      coll = db.collection(collection)
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      nil
    end
  end

  # returns true if a collection is dropped
  def drop_collection(collection)
    begin
      db = open_database()
      coll = db.collection(collection)
      coll.drop
      true
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      false
    end
  end

  # Retrieve documents for a given query hash and sort the results
  # returns an empty array if no rows are found
  def get_documents_by_hash_orderby(query_hash, collection, order_def)
    begin
      records = []
      db = open_database()

      coll = db.collection(collection)
      unless order_def.nil?
        records = coll.find(query_hash).sort(order_def)
      else
        records = coll.find(query_hash)
      end
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      records
    end
  end

  # returns if the target collection exists or not
  def collection_exist(collection)
    begin
      records = []
      db = open_database()
      coll = db.collection(collection)
      coll.count > 0
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      false
    end
  end

  def save_chunk_data(data)
    begin
      db = open_database()
      grid = open_grid(db)
      id = grid.put(data)
      id.to_s
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      doc_id
    end
  end

  def get_chunk_data(doc_id)
    begin
      db = open_database()
      grid = open_grid(db)
      data = grid.get(doc_id)
      data
    rescue Exception => e
      puts 'ERROR:  ' + e.message
      puts e.backtrace
      doc_id
    end
  end
end
